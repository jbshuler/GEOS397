
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>GEOS397_HW5_ShulerSimonEdits</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-10-13"><meta name="DC.source" content="GEOS397_HW5_ShulerSimonEdits.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Homework 5</a></li><li><a href="#2"><b>Part 1: Conductive heat flow</b></a></li><li><a href="#3">1.1: A model</a></li><li><a href="#4">1.2: Heat flow</a></li><li><a href="#5">1.3: Thermal conductivities</a></li><li><a href="#6">1.4: The heat transport equation</a></li><li><a href="#13">1.5: The conservation equation</a></li><li><a href="#19"><b>Part 2: Oceanic lithosphere cooling</b></a></li><li><a href="#20">2.1: Set up the model domain and compute</a></li><li><a href="#22">2.2: Analyze model output</a></li><li><a href="#24"><b>Part 3: Plate Velocity and the depth of oceans</b></a></li><li><a href="#25">3.1 Load and plot sea-floor depth data</a></li><li><a href="#27">3.2 A half-space model</a></li><li><a href="#32"><b>Part 4: Global Oceanic plate ages</b></a></li><li><a href="#33">4.1 Load topo data and plot sea-floor depths</a></li><li><a href="#34">4.2 Kill the topography and get the units right</a></li><li><a href="#37">4.3 Compute sea-floor age</a></li><li><a href="#38">4.4 Plot oceanic lithosphere age map</a></li><li><a href="#40">4.5 Discuss your results</a></li></ul></div><h2>Homework 5<a name="1"></a></h2><p><i><b>John Shuler and Simon Roy</b></i></p><p>GEOS597 Homework #5: Seafloor subsidence due to cooling</p><p>Due: 10/17/2016</p><pre class="codeinput">close <span class="string">all</span>;
clear <span class="string">all</span>;
clc;
</pre><h2><b>Part 1: Conductive heat flow</b><a name="2"></a></h2><h2>1.1: A model<a name="3"></a></h2><h2>1.2: Heat flow<a name="4"></a></h2><p>In this equation, the heat flow <i>down</i> is negative, which means that heat actually flows up, from higher temperature to lower temperture, as we would expect. Negative flow down ==&gt; positive Q up.</p><h2>1.3: Thermal conductivities<a name="5"></a></h2><div><ul><li><b>Thermal Conductivity (Watts/m*C):</b></li><li><b>Silver: 406</b></li><li><b>Magnesium: 156</b></li><li><b>Glass: 0.8</b></li><li><b>Rock: 2-7</b></li><li><b>Wood: 0.04-0.12</b></li></ul></div><p><b>from Young, Hugh D., University Physics, 7th Ed. Table 15-5</b> <b>from engineeringtoolbox.com</b></p><h2>1.4: The heat transport equation<a name="6"></a></h2><p>The heat transport equation will become:</p><p><img src="GEOS397_HW5_ShulerSimonEdits_eq13827883870824691172.png" alt="$$Q=-k\frac{T(z+dz)-T(z)}{dz}$$"></p><p>The derivative term on the right hand side =</p><p><img src="GEOS397_HW5_ShulerSimonEdits_eq07889681746011248493.png" alt="$$ \frac{\partial T}{\partial z} $$"></p><p>So the heat equation becomes:</p><p><img src="GEOS397_HW5_ShulerSimonEdits_eq12355685695441955261.png" alt="$$Q(T,z) = -k*\frac{\partial T}{\partial z}$$"></p><p>or</p><p><img src="GEOS397_HW5_ShulerSimonEdits_eq06616224562637161481.png" alt="$$Q(T,z) = -k*\nabla T$$"></p><h2>1.5: The conservation equation<a name="13"></a></h2><p>Compute derivative of Q:</p><p><img src="GEOS397_HW5_ShulerSimonEdits_eq14782764746036579272.png" alt="$$c_p\rho*\frac{\partial T}{\partial t} = A + k\frac{\partial^2 T}{\partial z^2}$$"></p><p>Heat generation A = 0  gives us:</p><p><img src="GEOS397_HW5_ShulerSimonEdits_eq07379430486783757476.png" alt="$$c_p\rho*\frac{\partial T}{\partial t} = k\frac{\partial^2 T}{\partial z^2}$$"></p><p>We can condense all the constants into a new value <img src="GEOS397_HW5_ShulerSimonEdits_eq16107531617707909724.png" alt="$\kappa$">, which will be equal to:</p><p><img src="GEOS397_HW5_ShulerSimonEdits_eq07968162976687104514.png" alt="$$\kappa = \frac{k}{c_p\rho}$$"></p><h2><b>Part 2: Oceanic lithosphere cooling</b><a name="19"></a></h2><h2>2.1: Set up the model domain and compute<a name="20"></a></h2><pre class="codeinput">z = 0:0.1:100;              <span class="comment">% depth [km]</span>
dz = z(2)-z(1);             <span class="comment">% depth step size [km]</span>
t = 0:1E5:1E8;              <span class="comment">% time [yr]</span>
dt = t(2)-t(1);             <span class="comment">% time step [yr]</span>
kappa = (1E-6);             <span class="comment">% thermal diffusivity [m^2/s]</span>
To = 640;                   <span class="comment">% initial temp. at ridge [deg. C]</span>
tic;
T = zeros(length(z),length(t));
<span class="keyword">for</span> j = 1:length(t);
    <span class="keyword">for</span> i = 1:length(z);
        T(i,j) = To * erf (z(i)./(2*sqrt(kappa*t(j))));
    <span class="keyword">end</span>
<span class="keyword">end</span>
runTime = toc;
</pre><p><b>EXTRA CREDIT: runTime &gt;&gt;&gt; runTime2. Using the piecewise matrix multiplication of two matrices rather than using two for loops is much less computationally expensive.</b></p><pre class="codeinput">h = figure;
imagesc(t, z, T);
c = colorbar;
c.Label.String = <span class="string">'Temperature \circC'</span>;
xlabel (<span class="string">'t [years]'</span>)
ylabel (<span class="string">'Depth [km]'</span>)
title(<span class="string">'Plate cooling as modeled using 2 "for" loops'</span>)


tic
[TIME, DEPTH] = meshgrid (t,z);
T2 = To * erf (DEPTH./(2*sqrt(kappa*TIME)));
runTime2 = toc;
h = figure;
imagesc(t, z, T2);
c = colorbar;
c.Label.String = <span class="string">'Temperature \circC'</span>;
xlabel (<span class="string">'t [years]'</span>)
ylabel (<span class="string">'Depth [km]'</span>)
title(<span class="string">'Plate cooling as modeled using meshgrid and multiplication'</span>)
</pre><img vspace="5" hspace="5" src="GEOS397_HW5_ShulerSimonEdits_01.png" alt=""> <img vspace="5" hspace="5" src="GEOS397_HW5_ShulerSimonEdits_02.png" alt=""> <h2>2.2: Analyze model output<a name="22"></a></h2><div><ul><li>This model makes sense given our boundary conditions. Newly formed parts of the plate are near the boundary condition value of 640C = To, while as time goes on (and depth increases) more of the plate is cooled by the ocean water due to conduction, and consequently more of the plate cools toward the ocean temperature(which we assumed, incorrectly, to be zero). The result is the temperature gradient we see in our figure.</li></ul></div><div><ul><li>Many factors control the rate of temperature decay:</li></ul></div><div><ol><li>Ocean Temperature</li><li>Specific heat of the water and plate</li><li>Density of the plate</li><li>Ocean currents/convection</li><li>The relative thermal conductivity(s)</li></ol></div><div><ul><li>We could relate this model with distance from the ridge axis if we know the plate velocity. We could multiply the age by the plate velocity, and we we would get back the distance from the ridge.</li></ul></div><div><ul><li>A more appropriate boundary condition for T(z=0) would be 4 degrees C, because we know that the temperature at a "deep enough" point in the ocean is a constant 4 degrees, which has to do with the thermal expansion of water.</li></ul></div><div><ul><li>640C seems like an appropriate temperature for a mid ocean ridge, since, essentially, magma is being cooled into solid rock at the ridge. Liquid magma (according to Wikipedia) ranges from approximately 700-1300C, taking a value at the lower end of this scale seems appropriate, since the magma will be on the verge of solidifying as the plate forms.</li></ul></div><h2><b>Part 3: Plate Velocity and the depth of oceans</b><a name="24"></a></h2><h2>3.1 Load and plot sea-floor depth data<a name="25"></a></h2><p>First we load our data:</p><pre class="codeinput">load(<span class="string">'spreadingData.mat'</span>);
</pre><p>Now we want a plot depth(z) vs distance from the ridge(x)</p><pre class="codeinput">h=figure;
subplot(2,1,1);
hold <span class="string">on</span>
plot(Bath.atlanticx,Bath.atlanticz);
title(<span class="string">'Atlantic Ocean'</span>);
xlabel(<span class="string">'Distance in km'</span>);
ylabel(<span class="string">'Depth in m'</span>);
subplot(2,1,2);
plot(Bath.pacificx,Bath.pacificz);
title(<span class="string">'Pacific Ocean'</span>);
xlabel(<span class="string">'Distance in km'</span>);
ylabel(<span class="string">'Depth in m'</span>);
</pre><img vspace="5" hspace="5" src="GEOS397_HW5_ShulerSimonEdits_03.png" alt=""> <h2>3.2 A half-space model<a name="27"></a></h2><p>For this step we will attempt to find a value for plate velocity that closely matches the depth data that we have.</p><pre class="codeinput">velocity = 45;  <span class="comment">% in [Km/Ma]</span>
dpacific = zeros(1,numel(Bath.pacificx));
<span class="keyword">for</span> ii = 1:numel(Bath.pacificx);
    dpacific(ii) = -(2.65 + 0.345*(Bath.pacificx(ii)/velocity)^(1/2));

<span class="keyword">end</span>
dpacific = dpacific*1E03;
</pre><p>Now for the Atlantic side</p><pre class="codeinput">velocity = 14;  <span class="comment">% in [Km/Ma]</span>
datlantic = zeros(1,numel(Bath.atlanticx));
<span class="keyword">for</span> ii = 1:numel(Bath.atlanticx);
    datlantic(ii) = -(2.65 + 0.345*(Bath.atlanticx(ii)/velocity)^(1/2));

<span class="keyword">end</span>
datlantic = datlantic*1E03;
</pre><p>Now we re-plot the previous data with the depths predicted by our simplified model</p><pre class="codeinput">h=figure;
subplot(2,1,1);
hold <span class="string">on</span>
plot(Bath.atlanticx,Bath.atlanticz);
plot(Bath.atlanticx,datlantic);
legend <span class="string">toggle</span>;
legend(<span class="string">'Empirical'</span>,<span class="string">'Model'</span>);
title(<span class="string">'Atlantic Ocean'</span>);
xlabel(<span class="string">'Distance in km'</span>);
ylabel(<span class="string">'Depth in m'</span>);
subplot(2,1,2);
hold <span class="string">on</span>
plot(Bath.pacificx,Bath.pacificz);
plot(Bath.pacificx,dpacific);

legend <span class="string">toggle</span>;
legend(<span class="string">'Empirical'</span>,<span class="string">'Model'</span>);
title(<span class="string">'Pacific Ocean'</span>);
xlabel(<span class="string">'Distance in km'</span>);
ylabel(<span class="string">'Depth in m'</span>);
</pre><img vspace="5" hspace="5" src="GEOS397_HW5_ShulerSimonEdits_04.png" alt=""> <p>The value 2.65 represents the depth at t=0, or the depth at the mid-ocean ridge in this model.</p><p>The best velocities we found to fit the data, which is somewhat a matter of opinion since we didn't do any calculations to show it, are as follows:</p><div><ol><li>Pacific: 45 km/Ma</li><li>Atlantic: 14 km/Ma</li></ol></div><p>This works out to 4.5 cm/yr for the Pacific and 1.4 cm/yr for the Atlantic</p><p>Published value for the Atlantic spreading: ~2.5cm/yr Pacific: ~10cm/yr</p><p>These values do not match our predictions exactly, but they are fairly reasonable considering our very simplified model.</p><h2><b>Part 4: Global Oceanic plate ages</b><a name="32"></a></h2><h2>4.1 Load topo data and plot sea-floor depths<a name="33"></a></h2><pre class="codeinput">load (<span class="string">'topo.mat'</span>);

h=figure;

h.InvertHardcopy=<span class="string">'off'</span>; <span class="comment">%  Ensure that the colors of the saved figure match the colors on the display</span>
h.Color=<span class="string">'k'</span>; <span class="comment">% changes background color</span>
h.Position=[100 100 1000 500]; <span class="comment">% sets image position and size(coords of lower left and upper right)</span>
h.PaperPositionMode=<span class="string">'auto'</span>; <span class="comment">% saves image position for print and figure projection</span>

<span class="comment">%%setup map axes</span>
ax=axesm(<span class="string">'Mollweid'</span>,<span class="string">'Frame'</span>,<span class="string">'on'</span>,<span class="string">'Grid'</span>,<span class="string">'on'</span>); <span class="comment">% sets projection type and turns frame and gridding on</span>
setm(ax,<span class="string">'MLabelLocation'</span>,60); <span class="comment">% sets position for labels of the longitude lines every 60 degrees</span>
setm(ax,<span class="string">'PLabelLocation'</span>,30); <span class="comment">% sets position for labels for latitude lines every 30 degrees</span>
mlabel(<span class="string">'MLabelParallel'</span>,0); <span class="comment">%labels longitude lines along the equator</span>
plabel(<span class="string">'PLabelMeridian'</span>,-25); <span class="comment">% labels latitude lines along the chosen meridian</span>
axis(<span class="string">'off'</span>); <span class="comment">% turns normal square axis off</span>
setm(ax,<span class="string">'FontColor'</span>,[0.9 0.9 0.9]); <span class="comment">% sets color of labels to work on black background</span>
setm(ax,<span class="string">'GColor'</span>,[0.9 0.9 0.9]); <span class="comment">% sets color of grid to work with black background</span>

c=colorbar(<span class="string">'color'</span>, [0.9 0.9 0.9]); <span class="comment">% adds colorbar and sets font color</span>
c.Label.String= <span class="string">'Elevation (m)'</span>; <span class="comment">% adds label to colorbar</span>

<span class="comment">% These commands add coastlines and plot elevation</span>
load(<span class="string">'coastlines'</span>); <span class="comment">% loads built-in MATLAB data called coastlines</span>
plotm(coastlat, coastlon);

LAT = topolatlim(1):topolatlim(2);
LON =  topolonlim(1):topolonlim(2);


[lon, lat] = meshgrid(LON,LAT); <span class="comment">% compute the lat/lon of every grid point in topo</span>
pcolorm(lat,lon,topo); <span class="comment">% plot the matrix of elevations on the map</span>
demcmap(topo); <span class="comment">% give it a better colormap</span>

<span class="comment">% load the plate boundary data and plot the plate boundaries</span>

[platelat, platelon] = importPlates(<span class="string">'All_boundaries.txt'</span>);
plotm(platelat,platelon,<span class="string">'k'</span>);
</pre><img vspace="5" hspace="5" src="GEOS397_HW5_ShulerSimonEdits_05.png" alt=""> <h2>4.2 Kill the topography and get the units right<a name="34"></a></h2><p>Set elevation above sea level to zero</p><pre class="codeinput"><span class="keyword">for</span> j = 1:numel(topo);
    <span class="keyword">if</span> topo(j) &gt;= 0;
        topo(j) = 0;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>Now I'll switch the values to be positive, and change the units to km</p><pre class="codeinput">depth = -topo./1000;
</pre><p>Now I'll plot this new depth matrix using the same figure commands as before:</p><pre class="codeinput">h=figure;

h.InvertHardcopy=<span class="string">'off'</span>; <span class="comment">%  Ensure that the colors of the saved figure match the colors on the display</span>
h.Color=<span class="string">'k'</span>; <span class="comment">% changes background color</span>
h.Position=[100 100 1000 500]; <span class="comment">% sets image position and size(coords of lower left and upper right)</span>
h.PaperPositionMode=<span class="string">'auto'</span>; <span class="comment">% saves image position for print and figure projection</span>

<span class="comment">%%setup map axes</span>
ax=axesm(<span class="string">'Mollweid'</span>,<span class="string">'Frame'</span>,<span class="string">'on'</span>,<span class="string">'Grid'</span>,<span class="string">'on'</span>); <span class="comment">% sets projection type and turns frame and gridding on</span>
setm(ax,<span class="string">'MLabelLocation'</span>,60); <span class="comment">% sets position for labels of the longitude lines every 60 degrees</span>
setm(ax,<span class="string">'PLabelLocation'</span>,30); <span class="comment">% sets position for labels for latitude lines every 30 degrees</span>
mlabel(<span class="string">'MLabelParallel'</span>,0); <span class="comment">%labels longitude lines along the equator</span>
plabel(<span class="string">'PLabelMeridian'</span>,-25); <span class="comment">% labels latitude lines along the chosen meridian</span>
axis(<span class="string">'off'</span>); <span class="comment">% turns normal square axis off</span>
setm(ax,<span class="string">'FontColor'</span>,[1 1 1]); <span class="comment">% sets color of labels to work on black background</span>
setm(ax,<span class="string">'GColor'</span>,[0.9 0.9 0.9]); <span class="comment">% sets color of grid to work with black background</span>

c=colorbar(<span class="string">'color'</span>, [0.9 0.9 0.9]); <span class="comment">% adds colorbar and sets font color</span>
c.Label.String= <span class="string">'Ocean Depth (km)'</span>; <span class="comment">% adds label to colorbar</span>

<span class="comment">% These commands add coastlines and plot elevation</span>
load(<span class="string">'coastlines'</span>); <span class="comment">% loads built-in MATLAB data called coastlines</span>
plotm(coastlat, coastlon);

LAT = topolatlim(1):topolatlim(2);
LON =  topolonlim(1):topolonlim(2);


[lon, lat] = meshgrid(LON,LAT); <span class="comment">% compute the lat/lon of every grid point in topo</span>
pcolorm(lat,lon,depth); <span class="comment">% plot the matrix of elevations on the map</span>
demcmap(depth); <span class="comment">% give it a better colormap</span>

<span class="comment">% load the plate boundary data and plot the plate boundaries</span>

[platelat, platelon] = importPlates(<span class="string">'All_boundaries.txt'</span>);
plotm(platelat,platelon,<span class="string">'k'</span>);

<span class="comment">% Use colormap suggested in assignment:</span>

colormap( flipud( jet(20) ) );
<span class="comment">% This command sets the color properties of the figure to a matrix</span>
<span class="comment">% of values, the flipud command flips the matrix upside-down, and jet(20) is the matrix of</span>
<span class="comment">% RGB values for the colors in the colormap, and 20 is the number of</span>
<span class="comment">% colors included.</span>
</pre><img vspace="5" hspace="5" src="GEOS397_HW5_ShulerSimonEdits_06.png" alt=""> <h2>4.3 Compute sea-floor age<a name="37"></a></h2><p>Rearranging equation (3) for t gives:</p><p><img src="GEOS397_HW5_ShulerSimonEdits_eq18033374823673676209.png" alt="$$t = (\frac{d-2.65}{0.345})^2$$"></p><h2>4.4 Plot oceanic lithosphere age map<a name="38"></a></h2><p>First we need a matrix with the ages in Ma as the entries, we will accomplish this using the above equation, then I'll set the values at the continent to -10 Ma as suggested.</p><pre class="codeinput">ageArray = zeros(180,360);

<span class="keyword">for</span> ii = 1:numel(depth);

    ageArray(ii) = ((depth(ii)-2.65)/(0.345))^2;

    <span class="keyword">if</span> ageArray(ii) == ((0-2.65)/0.345)^2;
        ageArray(ii) = -10;
    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><p>Now we want to plot the resulting figure.</p><pre class="codeinput">h=figure;

h.InvertHardcopy=<span class="string">'off'</span>; <span class="comment">%  Ensure that the colors of the saved figure match the colors on the display</span>
h.Color=<span class="string">'k'</span>; <span class="comment">% changes background color</span>
h.Position=[100 100 1000 500]; <span class="comment">% sets image position and size(coords of lower left and upper right)</span>
h.PaperPositionMode=<span class="string">'auto'</span>; <span class="comment">% saves image position for print and figure projection</span>

<span class="comment">%%setup map axes</span>
ax=axesm(<span class="string">'Mollweid'</span>,<span class="string">'Frame'</span>,<span class="string">'on'</span>,<span class="string">'Grid'</span>,<span class="string">'on'</span>); <span class="comment">% sets projection type and turns frame and gridding on</span>
setm(ax,<span class="string">'MLabelLocation'</span>,60); <span class="comment">% sets position for labels of the longitude lines every 60 degrees</span>
setm(ax,<span class="string">'PLabelLocation'</span>,30); <span class="comment">% sets position for labels for latitude lines every 30 degrees</span>
mlabel(<span class="string">'MLabelParallel'</span>,0); <span class="comment">%labels longitude lines along the equator</span>
plabel(<span class="string">'PLabelMeridian'</span>,-25); <span class="comment">% labels latitude lines along the chosen meridian</span>
axis(<span class="string">'off'</span>); <span class="comment">% turns normal square axis off</span>
setm(ax,<span class="string">'FontColor'</span>,[1 1 1]); <span class="comment">% sets color of labels to work on black background</span>
setm(ax,<span class="string">'GColor'</span>,[0.9 0.9 0.9]); <span class="comment">% sets color of grid to work with black background</span>

c=colorbar(<span class="string">'color'</span>, [0.9 0.9 0.9]); <span class="comment">% adds colorbar and sets font color</span>
c.Label.String= <span class="string">'Ocean Depth (km)'</span>; <span class="comment">% adds label to colorbar</span>

<span class="comment">% These commands add coastlines and plot elevation</span>
load(<span class="string">'coastlines'</span>); <span class="comment">% loads built-in MATLAB data called coastlines</span>
plotm(coastlat, coastlon);

LAT = topolatlim(1):topolatlim(2);
LON =  topolonlim(1):topolonlim(2);


[lon, lat] = meshgrid(LON,LAT); <span class="comment">% compute the lat/lon of every grid point in topo</span>
pcolorm(lat,lon,ageArray); <span class="comment">% plot the matrix of elevations on the map</span>
demcmap(ageArray); <span class="comment">% give it a better colormap</span>

<span class="comment">% load the plate boundary data and plot the plate boundaries</span>

[platelat, platelon] = importPlates(<span class="string">'All_boundaries.txt'</span>);
plotm(platelat,platelon,<span class="string">'k'</span>);


<span class="comment">% Then we want the colormap information from the assignment:</span>

cmap = flipud( jet(20) );  <span class="comment">% This creates a 20x3 matrix of RGB values called cmap,</span>
<span class="comment">% that is inverted to go from red to blue instead of blue to red.</span>
cmap = [0.5 0.5 0.5; cmap]; <span class="comment">% this adds gray as the first row of the colormap</span>
cmap(end,:) = []; <span class="comment">% removes the last row of cmap so it has 20 rows again</span>
colormap(cmap); <span class="comment">% Sets the colormap properties to use the matrix we created</span>
</pre><img vspace="5" hspace="5" src="GEOS397_HW5_ShulerSimonEdits_07.png" alt=""> <h2>4.5 Discuss your results<a name="40"></a></h2><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Homework 5
% _*John Shuler and Simon Roy*_
%
% GEOS597 Homework #5: Seafloor subsidence due to cooling
%
% Due: 10/17/2016

close all;
clear all;
clc;
%% *Part 1: Conductive heat flow*
%% 1.1: A model
%% 1.2: Heat flow
%
% In this equation, the heat flow _down_ is negative, which means that heat
% actually flows up, from higher temperature to lower temperture, as we
% would expect. Negative flow down ==> positive Q up. 
%
%% 1.3: Thermal conductivities
% 
% 
% * *Thermal Conductivity (Watts/m*C):*
% * *Silver: 406* 
% * *Magnesium: 156* 
% * *Glass: 0.8* 
% * *Rock: 2-7* 
% * *Wood: 0.04-0.12* 
%
% *from Young, Hugh D., University Physics, 7th Ed. Table 15-5* 
% *from engineeringtoolbox.com*
%% 1.4: The heat transport equation
% The heat transport equation will become:
%%
% $$Q=-k\frac{T(z+dz)-T(z)}{dz}$$
%%
% The derivative term on the right hand side =
%%
% $$ \frac{\partial T}{\partial z} $$
%
% So the heat equation becomes:
%%
% $$Q(T,z) = -k*\frac{\partial T}{\partial z}$$
%
%%
% or
%%
% $$Q(T,z) = -k*\nabla T$$
%% 1.5: The conservation equation
% Compute derivative of Q:
%%
% $$c_p\rho*\frac{\partial T}{\partial t} = A + k\frac{\partial^2 T}{\partial z^2}$$
%%
% Heat generation A = 0  gives us:
%%
% $$c_p\rho*\frac{\partial T}{\partial t} = k\frac{\partial^2 T}{\partial z^2}$$
% 
%%
% We can condense all the constants into a new value $\kappa$, which will
% be equal to:
%%
% $$\kappa = \frac{k}{c_p\rho}$$
%% *Part 2: Oceanic lithosphere cooling*
%% 2.1: Set up the model domain and compute
z = 0:0.1:100;              % depth [km]
dz = z(2)-z(1);             % depth step size [km]
t = 0:1E5:1E8;              % time [yr]
dt = t(2)-t(1);             % time step [yr]
kappa = (1E-6);             % thermal diffusivity [m^2/s]
To = 640;                   % initial temp. at ridge [deg. C]
tic;
T = zeros(length(z),length(t));
for j = 1:length(t);
    for i = 1:length(z);
        T(i,j) = To * erf (z(i)./(2*sqrt(kappa*t(j))));
    end
end
runTime = toc;
%%
% *EXTRA CREDIT: runTime >>> runTime2. Using the piecewise matrix 
% multiplication of two matrices rather than using two
% for loops is much less computationally expensive.*

h = figure;
imagesc(t, z, T);
c = colorbar;
c.Label.String = 'Temperature \circC';
xlabel ('t [years]')
ylabel ('Depth [km]')
title('Plate cooling as modeled using 2 "for" loops')


tic
[TIME, DEPTH] = meshgrid (t,z);
T2 = To * erf (DEPTH./(2*sqrt(kappa*TIME)));
runTime2 = toc;
h = figure;
imagesc(t, z, T2);
c = colorbar;
c.Label.String = 'Temperature \circC';
xlabel ('t [years]')
ylabel ('Depth [km]')
title('Plate cooling as modeled using meshgrid and multiplication')
%% 2.2: Analyze model output
%
% * This model makes sense given our boundary conditions. Newly formed
% parts of the plate are near the boundary condition value of 640C = To,
% while as time goes on (and depth increases) more of the plate is cooled by the
% ocean water due to conduction, and consequently more of the plate cools
% toward the ocean temperature(which we assumed, incorrectly, to be zero).
% The result is the temperature gradient we see in our figure.
%
% * Many factors control the rate of temperature decay:
%%
% # Ocean Temperature
% # Specific heat of the water and plate
% # Density of the plate
% # Ocean currents/convection
% # The relative thermal conductivity(s)
%
% * We could relate this model with distance from the ridge axis if we know
% the plate velocity. We could multiply the age by the plate velocity, and we
% we would get back the distance from the ridge.
%
% * A more appropriate boundary condition for T(z=0) would be 4 degrees C,
% because we know that the temperature at a "deep enough" point in the
% ocean is a constant 4 degrees, which has to do with the thermal expansion
% of water.
%
% * 640C seems like an appropriate temperature for a mid ocean ridge,
% since, essentially, magma is being cooled into solid rock at the ridge.
% Liquid magma (according to Wikipedia) ranges from approximately
% 700-1300C, taking a value at the lower end of this scale seems
% appropriate, since the magma will be on the verge of solidifying as the
% plate forms.
%
%% *Part 3: Plate Velocity and the depth of oceans*
%% 3.1 Load and plot sea-floor depth data
% First we load our data:
load('spreadingData.mat');
%% 
% Now we want a plot depth(z) vs distance from the ridge(x)
h=figure;
subplot(2,1,1);
hold on
plot(Bath.atlanticx,Bath.atlanticz);
title('Atlantic Ocean');
xlabel('Distance in km');
ylabel('Depth in m');
subplot(2,1,2);
plot(Bath.pacificx,Bath.pacificz);
title('Pacific Ocean');
xlabel('Distance in km');
ylabel('Depth in m');
%% 3.2 A half-space model
% For this step we will attempt to find a value for plate velocity that
% closely matches the depth data that we have.
%
velocity = 45;  % in [Km/Ma]
dpacific = zeros(1,numel(Bath.pacificx));
for ii = 1:numel(Bath.pacificx);
    dpacific(ii) = -(2.65 + 0.345*(Bath.pacificx(ii)/velocity)^(1/2));
    
end
dpacific = dpacific*1E03;
%%
% Now for the Atlantic side
velocity = 14;  % in [Km/Ma]
datlantic = zeros(1,numel(Bath.atlanticx));
for ii = 1:numel(Bath.atlanticx);
    datlantic(ii) = -(2.65 + 0.345*(Bath.atlanticx(ii)/velocity)^(1/2));
    
end
datlantic = datlantic*1E03;


%%
% Now we re-plot the previous data with the depths predicted by our
% simplified model
h=figure;
subplot(2,1,1);
hold on
plot(Bath.atlanticx,Bath.atlanticz);
plot(Bath.atlanticx,datlantic);
legend toggle;
legend('Empirical','Model');
title('Atlantic Ocean');
xlabel('Distance in km');
ylabel('Depth in m');
subplot(2,1,2);
hold on
plot(Bath.pacificx,Bath.pacificz);
plot(Bath.pacificx,dpacific);

legend toggle;
legend('Empirical','Model');
title('Pacific Ocean');
xlabel('Distance in km');
ylabel('Depth in m');
%%
% The value 2.65 represents the depth at t=0, or the depth at the mid-ocean
% ridge in this model.
% 
% The best velocities we found to fit the data, which is somewhat a matter
% of opinion since we didn't do any calculations to show it, are as
% follows:
%%
% # Pacific: 45 km/Ma
% # Atlantic: 14 km/Ma
%
% This works out to 4.5 cm/yr for the Pacific and 
% 1.4 cm/yr for the Atlantic
%
% Published value for the Atlantic spreading: ~2.5cm/yr
% Pacific: ~10cm/yr
%
% These values do not match our predictions exactly, but they are fairly
% reasonable considering our very simplified model. 
%% *Part 4: Global Oceanic plate ages*
%% 4.1 Load topo data and plot sea-floor depths
% 
%
load ('topo.mat');

h=figure;

h.InvertHardcopy='off'; %  Ensure that the colors of the saved figure match the colors on the display
h.Color='k'; % changes background color
h.Position=[100 100 1000 500]; % sets image position and size(coords of lower left and upper right)
h.PaperPositionMode='auto'; % saves image position for print and figure projection

%%setup map axes
ax=axesm('Mollweid','Frame','on','Grid','on'); % sets projection type and turns frame and gridding on
setm(ax,'MLabelLocation',60); % sets position for labels of the longitude lines every 60 degrees
setm(ax,'PLabelLocation',30); % sets position for labels for latitude lines every 30 degrees
mlabel('MLabelParallel',0); %labels longitude lines along the equator
plabel('PLabelMeridian',-25); % labels latitude lines along the chosen meridian
axis('off'); % turns normal square axis off
setm(ax,'FontColor',[0.9 0.9 0.9]); % sets color of labels to work on black background
setm(ax,'GColor',[0.9 0.9 0.9]); % sets color of grid to work with black background
 
c=colorbar('color', [0.9 0.9 0.9]); % adds colorbar and sets font color
c.Label.String= 'Elevation (m)'; % adds label to colorbar

% These commands add coastlines and plot elevation
load('coastlines'); % loads built-in MATLAB data called coastlines
plotm(coastlat, coastlon); 

LAT = topolatlim(1):topolatlim(2);
LON =  topolonlim(1):topolonlim(2);


[lon, lat] = meshgrid(LON,LAT); % compute the lat/lon of every grid point in topo
pcolorm(lat,lon,topo); % plot the matrix of elevations on the map
demcmap(topo); % give it a better colormap

% load the plate boundary data and plot the plate boundaries

[platelat, platelon] = importPlates('All_boundaries.txt');
plotm(platelat,platelon,'k');

%% 4.2 Kill the topography and get the units right
% Set elevation above sea level to zero
for j = 1:numel(topo);
    if topo(j) >= 0;
        topo(j) = 0;
    end
end

%%
% Now I'll switch the values to be positive, and change the units to km

depth = -topo./1000;

%%
% Now I'll plot this new depth matrix using the same figure commands as
% before:

h=figure;

h.InvertHardcopy='off'; %  Ensure that the colors of the saved figure match the colors on the display
h.Color='k'; % changes background color
h.Position=[100 100 1000 500]; % sets image position and size(coords of lower left and upper right)
h.PaperPositionMode='auto'; % saves image position for print and figure projection

%%setup map axes
ax=axesm('Mollweid','Frame','on','Grid','on'); % sets projection type and turns frame and gridding on
setm(ax,'MLabelLocation',60); % sets position for labels of the longitude lines every 60 degrees
setm(ax,'PLabelLocation',30); % sets position for labels for latitude lines every 30 degrees
mlabel('MLabelParallel',0); %labels longitude lines along the equator
plabel('PLabelMeridian',-25); % labels latitude lines along the chosen meridian
axis('off'); % turns normal square axis off
setm(ax,'FontColor',[1 1 1]); % sets color of labels to work on black background
setm(ax,'GColor',[0.9 0.9 0.9]); % sets color of grid to work with black background
 
c=colorbar('color', [0.9 0.9 0.9]); % adds colorbar and sets font color
c.Label.String= 'Ocean Depth (km)'; % adds label to colorbar

% These commands add coastlines and plot elevation
load('coastlines'); % loads built-in MATLAB data called coastlines
plotm(coastlat, coastlon); 

LAT = topolatlim(1):topolatlim(2);
LON =  topolonlim(1):topolonlim(2);


[lon, lat] = meshgrid(LON,LAT); % compute the lat/lon of every grid point in topo
pcolorm(lat,lon,depth); % plot the matrix of elevations on the map
demcmap(depth); % give it a better colormap

% load the plate boundary data and plot the plate boundaries

[platelat, platelon] = importPlates('All_boundaries.txt');
plotm(platelat,platelon,'k');

% Use colormap suggested in assignment:

colormap( flipud( jet(20) ) ); 
% This command sets the color properties of the figure to a matrix
% of values, the flipud command flips the matrix upside-down, and jet(20) is the matrix of 
% RGB values for the colors in the colormap, and 20 is the number of
% colors included.
 
%% 4.3 Compute sea-floor age
% Rearranging equation (3) for t gives:
%
% $$t = (\frac{d-2.65}{0.345})^2$$

%% 4.4 Plot oceanic lithosphere age map
%
% First we need a matrix with the ages in Ma as the entries, we will
% accomplish this using the above equation, then I'll set the values at the
% continent to -10 Ma as suggested.

ageArray = zeros(180,360);

for ii = 1:numel(depth);
     
    ageArray(ii) = ((depth(ii)-2.65)/(0.345))^2;
    
    if ageArray(ii) == ((0-2.65)/0.345)^2;
        ageArray(ii) = -10;
    end
    
end
%%
% Now we want to plot the resulting figure.

h=figure;

h.InvertHardcopy='off'; %  Ensure that the colors of the saved figure match the colors on the display
h.Color='k'; % changes background color
h.Position=[100 100 1000 500]; % sets image position and size(coords of lower left and upper right)
h.PaperPositionMode='auto'; % saves image position for print and figure projection

%%setup map axes
ax=axesm('Mollweid','Frame','on','Grid','on'); % sets projection type and turns frame and gridding on
setm(ax,'MLabelLocation',60); % sets position for labels of the longitude lines every 60 degrees
setm(ax,'PLabelLocation',30); % sets position for labels for latitude lines every 30 degrees
mlabel('MLabelParallel',0); %labels longitude lines along the equator
plabel('PLabelMeridian',-25); % labels latitude lines along the chosen meridian
axis('off'); % turns normal square axis off
setm(ax,'FontColor',[1 1 1]); % sets color of labels to work on black background
setm(ax,'GColor',[0.9 0.9 0.9]); % sets color of grid to work with black background
 
c=colorbar('color', [0.9 0.9 0.9]); % adds colorbar and sets font color
c.Label.String= 'Ocean Depth (km)'; % adds label to colorbar

% These commands add coastlines and plot elevation
load('coastlines'); % loads built-in MATLAB data called coastlines
plotm(coastlat, coastlon); 

LAT = topolatlim(1):topolatlim(2);
LON =  topolonlim(1):topolonlim(2);


[lon, lat] = meshgrid(LON,LAT); % compute the lat/lon of every grid point in topo
pcolorm(lat,lon,ageArray); % plot the matrix of elevations on the map
demcmap(ageArray); % give it a better colormap

% load the plate boundary data and plot the plate boundaries

[platelat, platelon] = importPlates('All_boundaries.txt');
plotm(platelat,platelon,'k');


% Then we want the colormap information from the assignment:

cmap = flipud( jet(20) );  % This creates a 20x3 matrix of RGB values called cmap, 
% that is inverted to go from red to blue instead of blue to red.
cmap = [0.5 0.5 0.5; cmap]; % this adds gray as the first row of the colormap
cmap(end,:) = []; % removes the last row of cmap so it has 20 rows again
colormap(cmap); % Sets the colormap properties to use the matrix we created

%% 4.5 Discuss your results
%
% 
##### SOURCE END #####
--></body></html>